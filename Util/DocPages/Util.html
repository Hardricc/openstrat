<html>
 <head>
    <title>Util Module</title>
    <link rel="stylesheet" type="text/css" href="https://richstrat.com/Documentation/documentation.css">
    <meta content="">
</head>

<body>
<h1>Util Module</h1>
<div class ="main">
	<h2>Contents</h2>
	The Util module contains
	<ol>
		<li class ="main">Functional error system.
		<li>Parser for tokens and AST.</li>
		<li>Show and persistence frame work</li>
		<li>Immutable Array based collection system inlcuding flat Array[Int] and Array[double] based compound value collections of same length elements.
		</li>
	</ol>
</div>

<div class ="main">
	<h2>Tokeniser</h2>
	<p>The Tokeniser will create the following tokens
		<ul>
			<li>Keytokens <span class=lexical>_ ? ?? ???</span></li>
			<li>Identifiers alphanumeric tokens starting with a letter that can contain, alphabetic, numerical and underscore characters.</li>
			<li>Operators</li>
			<li>numeric literals <span class=lexical>7, 7f 7.01, 7.01d, , 724F, 724W, 3.0.0, 3.0.1rc, 192.168.1.1</span></li>
			<li>Seperators , . .. ... { } etc.</li>
			<li>String literals</li>
			<li>Character literals</li>			
			<li>Comments</li>
		</ul>
	</p>

	<p>KeyTokens, Identifiers, and literals are all expressions. Operators, seperators and comments are not. Identifers includes lexemes such as
	 <span class=lexical>if, IF true and TRUE</span>. There are no alphabetic keywords in RSON syntax. Consumers of RSON syntax can of course treat	what
	  ever identifers they want as keywords appropriate to their use case. Identifers are categorised into 3 types.
	  <ul>
	  	<li>IdentUnder An identifer beginning with an undrscore character</li>
			<li>IdentLow And identifer beginning with a lower case alphabetic character.</li>
			<li>IdentUp An identifer beginning with an upper case alphabetic character. Some of these tokens will also be consider valid raw Base32 tokens,
			 and a subset of these will also be considered valid raw Hexadecimals, however all the alphabetic characters must be lower case.
			</li>
		</ul>
		Numerical literals come in 4 types. All 4 types can have optional trailing lower case alphabetic characters at the end of the token.
		<ul>
			<li>Floating point numbers <span class=lexical>6.02e23, 6.02e-23, 6.02e-23d</span> .Note this is the only case where a negative or dash
			 character is included as part of a token.
			</li>
			<li>Explicit hexadecimals 0x433A 0x2222
		</ul>
	</p>

  <table>
    <tr><td>LetterChar</td>                  <td>= unicode_letter | '_'</td></tr>
    <tr><td>NonZeroDigit</td>                <td>= '1' ... '9'</td></tr>
    <tr><td>DigitChar</td>                   <td>= '0' | NonZeroDigit</td></tr>
    <tr><td>HexaDigitChar</td>               <td>= DigitChar | 'A' ... 'F' | 'a' ... 'f'</td></tr>
    <tr><td>LetterOrDigitChar</td>           <td>= LetterChar | DigitChar</td></tr>
    <tr><td>LetterOrUnderscoreChar</td>      <td>= LetterChar | '_'</td></tr>   
    <tr><td>UnderscoreThenLetterOrDigit</td> <td>= '_', LetterOrDigitChar</td></tr>
    <tr><td>Dot3Token</td>                   <td>= "..."</td></tr>
    <tr><td>Dot2Token</td>                   <td>= ".."</td></tr>
    <tr><td>DotToken</td>                    <td>= '.'</td></tr>
    </table>
    <br>
    <table>  
    <tr><td>IdentifierToken</td>             <td>= letter | UnderscoreThenLetterOrDigit, { LetterOrDigitChar | UnderscoreThenLetterOrDigit }</td></tr>
    <tr><td>DeciLitToken</td>                <td>= '0' | (NonZeroDigit { DigitChar })</td></tr>
  </table>
</div>
<div class="main">
	<h2>Abstract Syntax Tree</h2>
  <p>AST Precedence From lowest to highest after brace block parsing.
  	<ul>
  	  <li>SemicolonToken Delimits the end of a Statement. The last Statement of a block /file may have, but does not need a need a trailing Semicolon. A statement without commas is considered Unclaused.</li>
  	  <li>CommaToken Delimits the end of clause. The last Clause of a Statement may have, but does not need a trailing Comma, unless it is a single Clause Statment in which case it must have a trailing Comma to 
  	  distinguish it from an Unclaused Statement.</li>
  	  <li>assignment operators. == and != are normal operators. Any other operators ending with a '=" character are assignment operators.</li>
      <li>The single Colon Token</li>
      <li>| From here on down the precedence is determined by the first character of the operator. An operator ending in a ':' will be expected to be an infix operator dispatch from its rhs.</li>
      <li>^</li>
      <li>&</li>
      <li>= !</li>
      <li>:</li>
      <li>+ -</li>
      <li>* / %</li>
      <li>All other special charachters</li>
      <li>Whitespace</li>
  </ul>
  </p>
  <h2>Hexadecimal and Base32</h2>
  <p>Hexadecimal is written with Uppercase letters. Base32 is written with the digits followed by the upper case letters A to W, with the letters 'I' and 'O' missing.
  </p>
</div>
<div class ="main">
  <h2>Miscellaneous</h2>
  <p>A Lower case letter will be use after numerals in names.</p>
</div>
</body>
</html>
